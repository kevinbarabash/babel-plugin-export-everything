# babel-plugin-export-everything

The goal of this babel plugin is to make it easier mock things when
writing unit tests without having to change how you'd normally code.
In particular it allows you to mock top-level functions and variables
from any source module even if it hasn't been exported.

## Writing tests

foo.js
```js
const fooMsg = "foo";

export const foo = () => fooMsg;
```

foobar.js
```js
import {foo} from "./foo.js";

const barMsg = "bar";
const bar = () => barMsg;

export const foobar = () => {
    return foo() + bar();
};
```

example.test.js
```js
test("mocking private variable", () => {
    mockValue(FooBar, "barMsg", "baz");

    expect(FooBar.foobar()).toEqual("foobaz");
});

test("mocking private function", () => {
    jest.spyOn(FooBar, "bar").mockReturnValue("baz")

    expect(FooBar.foobar()).toEqual("foobaz");
});

test("mocking private variable in dependency", () => {
    mockValue(Foo, "fooMsg", "qux");

    expect(FooBar.foobar()).toEqual("quxbar");
});

test("mocking function from dependency", () => {
    jest.spyOn(Foo, "foo").mockReturnValue("qux")

    expect(FooBar.foobar()).toEqual("quxbar");
});
```

See the [example.test.js](example/example.test.js) for the full test
suite.

## How it works

All top-level declarations in all non-test modules to be named exports
using commonjs' `exports` object and updates all references to each
variable accordingly.

input.js
```js
const msg = "foo";
const foo = () => msg;
export const foobar = () => `${foo()}bar`;
```

output.js
```js
Object.defineProperty(exports, "msg", {
    enumerable: true,
    configurable: true,
    get: () => "foo",
});
exports.foo = () => exports.msg;
exports.foobar = () => `${exports.foo()}bar`;
Object.defineProperty(exports, "__esModule", {
    value: true,
});
```

The reason for setting `exports.__esModule = true` at the end is that
other modules importing this module may end up using `_interopRequireDefault`
in the code generated by babel.  This helper has the following defintion:

```js
function _interopRequireDefault(obj) {
    return obj && obj.__esModule 
        ? obj 
        : { default: obj };
}

const Foo = _interopRequireDefault(require("./output.js"));
```

In order have consistent operation regardless of whether the helper is
being used or not, we need to set `__esModule = true` so that we always
returns whatever is returned by calls to `require`.

## Current Limitations:

- In order to mock default exports you have to use `require` to import
  the module you want to mock in your tests.
- I still need to test class exports as well as local class variables.
  Ideally, we'd want to ensure that we can mock any privately defined
  React components within a module.
