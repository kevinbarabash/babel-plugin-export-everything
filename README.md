# babel-plugin-export-everything

The goal of this babel plugin is to make it easier mock things when
writing unit tests without having to change how you'd normally code.
In particular it allows you to mock top-level functions and variables
from any source module even if it hasn't been exported.

## Writing tests

foo.js
```js
const msg = "foo";

export const foo = () => msg;
```

foobar.js
```js
import {foo} from "./foo.js";

const msg = "bar";
const bar = () => msg;

export const foobar = () => {
    return foo() + bar();
};
```

example.test.js
```js
const mockValue = (obj, prop, value) => {
    jest.spyOn(obj, prop, "get").mockReturnValue(value);
};

test("mocking private variable", () => {
    mockValue(FooBar, "msg", "baz");

    expect(FooBar.foobar()).toEqual("foobaz");
});

test("mocking private function", () => {
    jest.spyOn(FooBar, "bar").mockReturnValue("baz")

    expect(FooBar.foobar()).toEqual("foobaz");
});

test("mocking private variable in dependency", () => {
    mockValue(Foo, "msg", "qux");

    expect(FooBar.foobar()).toEqual("quxbar");
});

test("mocking function from dependency", () => {
    jest.spyOn(Foo, "foo").mockReturnValue("qux")

    expect(FooBar.foobar()).toEqual("quxbar");
});
```

See the [example.test.js](example/example.test.js) for the full test
suite.

## How it works

All top-level declarations in all non-test modules to be named exports
using commonjs' `exports` object and updates all references to each
variable accordingly.

input.js
```js
const msg = "foo";
const foo = () => msg;
export const foobar = () => `${foo()}bar`;
```

output.js
```js
Object.defineProperty(exports, "msg", {
    enumerable: true,
    configurable: true,
    get: () => "foo",
});
exports.foo = () => exports.msg;
exports.foobar = () => `${exports.foo()}bar`;
Object.defineProperty(exports, "__esModule", {
    value: true,
});
```

The reason for setting `exports.__esModule = true` at the end is that
other modules importing this module may end up using `_interopRequireDefault`
in the code generated by babel.  This helper has the following defintion:

```js
function _interopRequireDefault(obj) {
    return obj && obj.__esModule 
        ? obj 
        : { default: obj };
}

const Foo = _interopRequireDefault(require("./output.js"));
```

In order have consistent operation regardless of whether the helper is
being used or not, we need to set `__esModule = true` so that we always
returns whatever is returned by calls to `require`.

## TODOs:

- I still need to test class exports as well as local class variables.
  Ideally, we'd want to ensure that we can mock any privately defined
  React components within a module.
- Check that `require`-ing dependencies still works in code under test.

## Developing

jest caches compiled files so often times you'll need to clear the cache
before your changes will show up.  This can be done by running:

```
yarn test --clearCache
```
